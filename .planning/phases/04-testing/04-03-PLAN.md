---
phase: 04-testing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/test_solver_correctness.py
autonomous: true

must_haves:
  truths:
    - "QUBO one-hot constraints are satisfied in all solutions"
    - "Priority nodes appear before normal nodes in solutions"
    - "Mock sampler returns complete routes visiting all nodes"
    - "Route validation correctly identifies constraint violations"
  artifacts:
    - path: "backend/tests/test_solver_correctness.py"
      provides: "Solver correctness test suite"
      min_lines: 120
  key_links:
    - from: "backend/tests/test_solver_correctness.py"
      to: "backend/src/qubo_builder.py"
      via: "build_qubo, validate_route imports"
      pattern: "from src.qubo_builder import"
    - from: "backend/tests/test_solver_correctness.py"
      to: "backend/src/qaoa_solver.py"
      via: "MockSampler import"
      pattern: "from src.qaoa_solver import"
---

<objective>
Create QUBO and solver correctness tests for TEST-03 and TEST-04

Purpose: Verify that QUBO constraints are properly encoded, solutions satisfy one-hot constraints, priority ordering is enforced, and the mock sampler produces valid complete routes.

Output: `backend/tests/test_solver_correctness.py` with comprehensive solver correctness coverage
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@backend/src/qubo_builder.py
@backend/src/qaoa_solver.py
@backend/tests/test_qubo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QUBO constraint verification tests</name>
  <files>backend/tests/test_solver_correctness.py</files>
  <action>
Create `backend/tests/test_solver_correctness.py` with QUBO correctness tests:

**Setup fixtures:**
```python
import pytest
from src.data_models import Node, Edge, CityGraph, NodeType, TrafficLevel, QUBOParams
from src.qubo_builder import build_qubo, decode_route, validate_route
from src.qaoa_solver import MockSampler, quantum_solve

@pytest.fixture
def small_graph():
    """4-node graph: 2 priority, 2 normal."""
    nodes = [
        Node(id="P1", x=0, y=0, type=NodeType.PRIORITY),
        Node(id="P2", x=1, y=0, type=NodeType.PRIORITY),
        Node(id="N1", x=0, y=1, type=NodeType.NORMAL),
        Node(id="N2", x=1, y=1, type=NodeType.NORMAL),
    ]
    edges = [
        Edge(from_node="P1", to_node="P2", distance=1.0, traffic=TrafficLevel.LOW),
        Edge(from_node="P1", to_node="N1", distance=1.0, traffic=TrafficLevel.LOW),
        Edge(from_node="P2", to_node="N2", distance=1.0, traffic=TrafficLevel.LOW),
        Edge(from_node="N1", to_node="N2", distance=1.0, traffic=TrafficLevel.LOW),
        Edge(from_node="P1", to_node="N2", distance=1.41, traffic=TrafficLevel.MEDIUM),
        Edge(from_node="P2", to_node="N1", distance=1.41, traffic=TrafficLevel.MEDIUM),
    ]
    return CityGraph(nodes=nodes, edges=edges)

@pytest.fixture
def large_graph():
    """8-node graph for more thorough testing."""
    # 3 priority, 5 normal nodes in a grid
    nodes = [
        Node(id=f"P{i}", x=i, y=0, type=NodeType.PRIORITY) for i in range(3)
    ] + [
        Node(id=f"N{i}", x=i % 3, y=1 + i // 3, type=NodeType.NORMAL) for i in range(5)
    ]
    # Fully connected for simplicity
    edges = []
    for i, n1 in enumerate(nodes):
        for j, n2 in enumerate(nodes):
            if i < j:
                dist = ((n1.x - n2.x)**2 + (n1.y - n2.y)**2)**0.5
                edges.append(Edge(
                    from_node=n1.id, to_node=n2.id,
                    distance=round(dist, 2), traffic=TrafficLevel.LOW
                ))
    return CityGraph(nodes=nodes, edges=edges)
```

**Class: TestQUBOOneHotConstraints**
- `test_one_hot_per_position` - Verify each position has exactly one node assigned
- `test_one_hot_per_node` - Verify each node appears at exactly one position
- `test_one_hot_with_mock_sampler` - Run MockSampler, verify one-hot in result

Helper function:
```python
def verify_one_hot(sample: dict, n_nodes: int) -> tuple[bool, str]:
    """Verify one-hot constraints are satisfied in a sample.

    Returns (satisfied, error_message).
    """
    # Check each position has exactly one node
    for pos in range(n_nodes):
        count = sum(1 for k, v in sample.items()
                    if v == 1 and k.endswith(f"_{pos}"))
        if count != 1:
            return False, f"Position {pos} has {count} nodes (expected 1)"

    # Check each node appears exactly once
    node_counts = {}
    for key, val in sample.items():
        if val == 1:
            parts = key.split("_")
            node_id = "_".join(parts[1:-1])
            node_counts[node_id] = node_counts.get(node_id, 0) + 1

    for node_id, count in node_counts.items():
        if count != 1:
            return False, f"Node {node_id} appears {count} times (expected 1)"

    return True, ""
```

**Class: TestPriorityOrdering**
- `test_priority_nodes_first_in_route` - Verify priority nodes come before normal
- `test_all_priority_visited` - Verify all priority nodes are in the route
- `test_priority_constraint_penalty` - Verify QUBO has penalties for wrong positions
- `test_priority_satisfied_flag` - Verify validate_route returns correct priority_satisfied
  </action>
  <verify>
Run: `cd backend && python -m pytest tests/test_solver_correctness.py::TestQUBOOneHotConstraints -v`
Run: `cd backend && python -m pytest tests/test_solver_correctness.py::TestPriorityOrdering -v`
All tests should pass.
  </verify>
  <done>
- One-hot constraint verification helper exists
- Tests verify position one-hot (each position has 1 node)
- Tests verify node one-hot (each node at 1 position)
- Priority ordering tests verify constraints
  </done>
</task>

<task type="auto">
  <name>Task 2: Create mock sampler completeness tests</name>
  <files>backend/tests/test_solver_correctness.py</files>
  <action>
Add tests for mock sampler route completeness (TEST-04):

**Class: TestMockSamplerCompleteness**
```python
class TestMockSamplerCompleteness:
    """Tests that MockSampler produces complete, valid routes."""

    def test_visits_all_nodes_small(self, small_graph):
        """Mock sampler should visit all nodes in small graph."""
        result = quantum_solve(small_graph, use_mock=True)

        node_ids = {n.id for n in small_graph.nodes}
        route_ids = set(result.route)

        assert route_ids == node_ids, \
            f"Route missing nodes: {node_ids - route_ids}"

    def test_visits_all_nodes_large(self, large_graph):
        """Mock sampler should visit all nodes in larger graph."""
        result = quantum_solve(large_graph, use_mock=True)

        node_ids = {n.id for n in large_graph.nodes}
        route_ids = set(result.route)

        assert route_ids == node_ids, \
            f"Route missing nodes: {node_ids - route_ids}"

    def test_no_duplicate_nodes(self, small_graph):
        """Route should not have duplicate nodes."""
        result = quantum_solve(small_graph, use_mock=True)

        assert len(result.route) == len(set(result.route)), \
            f"Route has duplicates: {result.route}"

    def test_feasible_flag_true(self, small_graph):
        """Feasible flag should be True for valid route."""
        result = quantum_solve(small_graph, use_mock=True)
        assert result.feasible is True

    def test_priority_satisfied_true(self, small_graph):
        """Priority satisfied flag should be True when priorities first."""
        result = quantum_solve(small_graph, use_mock=True)
        # Mock sampler uses greedy which should respect priority
        # Verify manually
        priority_ids = {n.id for n in small_graph.priority_nodes}
        k = len(priority_ids)

        # First k nodes should all be priority
        first_k = set(result.route[:k])
        assert first_k == priority_ids or result.priority_satisfied is True

    def test_route_length_equals_node_count(self, small_graph):
        """Route length should equal number of nodes."""
        result = quantum_solve(small_graph, use_mock=True)
        assert len(result.route) == len(small_graph.nodes)

    def test_metrics_are_finite(self, small_graph):
        """Distance and time should be finite for valid route."""
        result = quantum_solve(small_graph, use_mock=True)

        assert result.total_distance < float('inf')
        assert result.travel_time < float('inf')
        assert result.total_distance > 0
        assert result.travel_time > 0
```

**Class: TestMockSamplerDeterminism**
```python
class TestMockSamplerDeterminism:
    """Tests for mock sampler behavior consistency."""

    def test_same_graph_same_route(self, small_graph):
        """Same graph should produce same route (deterministic)."""
        result1 = quantum_solve(small_graph, use_mock=True)
        result2 = quantum_solve(small_graph, use_mock=True)

        assert result1.route == result2.route

    def test_energy_is_finite(self, small_graph):
        """QUBO energy should be a finite number."""
        result = quantum_solve(small_graph, use_mock=True)

        assert result.energy is not None
        assert result.energy < float('inf')
```
  </action>
  <verify>
Run: `cd backend && python -m pytest tests/test_solver_correctness.py::TestMockSamplerCompleteness -v`
Run: `cd backend && python -m pytest tests/test_solver_correctness.py::TestMockSamplerDeterminism -v`
All tests should pass.
  </verify>
  <done>
- Mock sampler tests verify all nodes visited
- Tests verify no duplicate nodes in route
- Tests verify feasible and priority_satisfied flags
- Tests verify metrics are finite positive values
- Determinism test verifies consistent behavior
  </done>
</task>

<task type="auto">
  <name>Task 3: Add route validation edge case tests</name>
  <files>backend/tests/test_solver_correctness.py</files>
  <action>
Add edge case tests for route validation:

**Class: TestRouteValidationEdgeCases**
```python
class TestRouteValidationEdgeCases:
    """Edge case tests for validate_route function."""

    def test_empty_route(self, small_graph):
        """Empty route should be infeasible."""
        feasible, priority_satisfied = validate_route([], small_graph)
        assert feasible is False

    def test_partial_route(self, small_graph):
        """Route missing nodes should be infeasible."""
        partial = ["P1", "P2"]  # Missing N1, N2
        feasible, priority_satisfied = validate_route(partial, small_graph)
        assert feasible is False

    def test_duplicate_nodes_in_route(self, small_graph):
        """Route with duplicates should be infeasible."""
        with_dup = ["P1", "P2", "P1", "N1"]
        feasible, priority_satisfied = validate_route(with_dup, small_graph)
        assert feasible is False

    def test_unknown_node_in_route(self, small_graph):
        """Route with unknown node should be infeasible."""
        unknown = ["P1", "P2", "N1", "UNKNOWN"]
        feasible, priority_satisfied = validate_route(unknown, small_graph)
        assert feasible is False

    def test_priority_violated_but_complete(self, small_graph):
        """Complete route with wrong order should be feasible but priority_satisfied=False."""
        wrong_order = ["N1", "P1", "P2", "N2"]  # Normal before priority
        feasible, priority_satisfied = validate_route(wrong_order, small_graph)
        assert feasible is True  # All nodes visited
        assert priority_satisfied is False  # Wrong order

    def test_all_priority_graph(self):
        """Graph with only priority nodes should work."""
        nodes = [
            Node(id="P1", x=0, y=0, type=NodeType.PRIORITY),
            Node(id="P2", x=1, y=0, type=NodeType.PRIORITY),
        ]
        edges = [Edge(from_node="P1", to_node="P2", distance=1.0, traffic=TrafficLevel.LOW)]
        graph = CityGraph(nodes=nodes, edges=edges)

        feasible, priority_satisfied = validate_route(["P1", "P2"], graph)
        assert feasible is True
        assert priority_satisfied is True

    def test_all_normal_graph(self):
        """Graph with only normal nodes should work."""
        nodes = [
            Node(id="N1", x=0, y=0, type=NodeType.NORMAL),
            Node(id="N2", x=1, y=0, type=NodeType.NORMAL),
        ]
        edges = [Edge(from_node="N1", to_node="N2", distance=1.0, traffic=TrafficLevel.LOW)]
        graph = CityGraph(nodes=nodes, edges=edges)

        feasible, priority_satisfied = validate_route(["N1", "N2"], graph)
        assert feasible is True
        assert priority_satisfied is True  # No priority nodes to violate
```
  </action>
  <verify>
Run: `cd backend && python -m pytest tests/test_solver_correctness.py::TestRouteValidationEdgeCases -v`
All tests should pass.
  </verify>
  <done>
- Empty route test exists
- Partial route test exists
- Duplicate node test exists
- Unknown node test exists
- Priority violation test exists
- All-priority graph test exists
- All-normal graph test exists
  </done>
</task>

</tasks>

<verification>
Run the complete test suite to ensure no regressions:
```bash
cd backend && python -m pytest tests/ -v
```

Verify specific coverage of TEST-03 and TEST-04 requirements:
- QUBO one-hot: At least 3 test cases
- Priority ordering: At least 4 test cases
- Mock sampler completeness: At least 6 test cases
- Route validation edge cases: At least 7 test cases
</verification>

<success_criteria>
1. `backend/tests/test_solver_correctness.py` exists with 20+ test cases
2. All tests pass when run with pytest
3. Tests cover all TEST-03 success criteria:
   - QUBO one-hot constraints verified
   - Priority nodes appear before normal nodes
4. Tests cover all TEST-04 success criteria:
   - Mock sampler returns complete routes
   - All nodes are visited
5. Edge cases for route validation are covered
</success_criteria>

<output>
After completion, create `.planning/phases/04-testing/04-03-SUMMARY.md`
</output>
