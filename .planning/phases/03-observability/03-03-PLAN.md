---
phase: 03-observability
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/main.py
  - backend/app/middleware.py
autonomous: true

must_haves:
  truths:
    - "Every request has a unique correlation ID accessible throughout request lifecycle"
    - "Errors logged server-side include full context (request_id, path, method, error details)"
    - "Error responses to clients include only request_id for support reference"
    - "Request ID is available in request.state for all handlers"
  artifacts:
    - path: "backend/app/middleware.py"
      provides: "Request context middleware with correlation ID"
      exports: ["RequestContextMiddleware", "get_request_id"]
    - path: "backend/app/main.py"
      provides: "Error handlers using request context"
      contains: "request_id"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/middleware.py"
      via: "import and middleware registration"
      pattern: "from app.middleware import"
    - from: "global_exception_handler"
      to: "request.state.request_id"
      via: "access request_id for logging and response"
      pattern: "request\\.state\\.request_id"
---

<objective>
Implement request correlation IDs that persist through the entire request lifecycle, enabling error tracking and support workflows.

Purpose: When users report errors, operators need to trace the exact request in logs. By returning only request_id to clients and logging full context server-side, we maintain security (no internal details leaked) while enabling support (request_id links to full logs).

Output: Middleware that assigns request_id to every request, makes it available throughout handlers, and ensures error responses include request_id for support reference.
</objective>

<execution_context>
@.claude/workflows/execute-plan.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-observability/03-01-PLAN.md
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request context middleware</name>
  <files>backend/app/middleware.py</files>
  <action>
    1. Create backend/app/middleware.py with:

    ```python
    """
    Request context middleware for correlation IDs and request tracking.
    """
    import uuid
    import time
    from contextvars import ContextVar
    from starlette.middleware.base import BaseHTTPMiddleware
    from starlette.requests import Request
    from starlette.responses import Response

    # Context variable for request ID (accessible anywhere in async context)
    _request_id_ctx: ContextVar[str | None] = ContextVar("request_id", default=None)

    def get_request_id() -> str | None:
        """Get current request ID from context."""
        return _request_id_ctx.get()

    class RequestContextMiddleware(BaseHTTPMiddleware):
        """
        Middleware that assigns a unique request ID to each request.

        - Generates UUID for each request
        - Stores in request.state.request_id
        - Sets context variable for access anywhere
        - Adds X-Request-ID response header
        """

        async def dispatch(self, request: Request, call_next) -> Response:
            # Generate or extract request ID
            request_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())

            # Store in request state (for handlers)
            request.state.request_id = request_id

            # Store in context var (for logging anywhere)
            token = _request_id_ctx.set(request_id)

            # Record timing
            request.state.start_time = time.time()

            try:
                response = await call_next(request)

                # Add request ID to response headers
                response.headers["X-Request-ID"] = request_id

                return response
            finally:
                # Reset context var
                _request_id_ctx.reset(token)
    ```

    2. Export RequestContextMiddleware and get_request_id
  </action>
  <verify>
    ```bash
    cd backend && python -c "from app.middleware import RequestContextMiddleware, get_request_id; print('OK')"
    ```
    - Import succeeds
  </verify>
  <done>Request context middleware exists with get_request_id helper function</done>
</task>

<task type="auto">
  <name>Task 2: Integrate middleware and update error handlers</name>
  <files>backend/app/main.py</files>
  <action>
    1. Import and register middleware:
       ```python
       from app.middleware import RequestContextMiddleware, get_request_id

       # Add BEFORE CORS middleware (order matters - first added = outermost)
       app.add_middleware(RequestContextMiddleware)
       ```

    2. Update global_exception_handler to use request_id:
       ```python
       @app.exception_handler(Exception)
       async def global_exception_handler(request: Request, exc: Exception):
           """Catch-all for unexpected errors. Logs full details, returns safe message with request_id."""
           request_id = getattr(request.state, "request_id", "unknown")

           # Log full context server-side (structlog will include request_id if configured)
           logger.error(
               "unhandled_exception",
               request_id=request_id,
               method=request.method,
               path=request.url.path,
               error_type=type(exc).__name__,
               error_message=str(exc),
               exc_info=True
           )

           # Return safe message with request_id for support reference
           return JSONResponse(
               status_code=500,
               content={
                   "detail": "An internal error occurred. Please try again later.",
                   "request_id": request_id
               }
           )
       ```

    3. Update http_exception_handler similarly:
       ```python
       @app.exception_handler(StarletteHTTPException)
       async def http_exception_handler(request: Request, exc: StarletteHTTPException):
           """Handle HTTP exceptions with consistent format including request_id."""
           request_id = getattr(request.state, "request_id", "unknown")
           return JSONResponse(
               status_code=exc.status_code,
               content={
                   "detail": exc.detail,
                   "request_id": request_id
               }
           )
       ```

    4. Update validation_exception_handler:
       ```python
       @app.exception_handler(RequestValidationError)
       async def validation_exception_handler(request: Request, exc: RequestValidationError):
           """Handle Pydantic validation errors with field-specific messages."""
           request_id = getattr(request.state, "request_id", "unknown")
           errors = []
           for error in exc.errors():
               field = ".".join(str(loc) for loc in error["loc"])
               errors.append({"field": field, "message": error["msg"]})
           return JSONResponse(
               status_code=400,
               content={
                   "detail": "Validation error",
                   "errors": errors,
                   "request_id": request_id
               }
           )
       ```

    5. Update logging middleware (if exists from 03-01) to use the request_id from state
       rather than generating its own (middleware.py is the single source of truth)
  </action>
  <verify>
    ```bash
    cd backend && uvicorn app.main:app --reload &
    sleep 2

    # Test normal request - should have X-Request-ID header
    curl -v http://localhost:8000/health 2>&1 | grep -i x-request-id

    # Test error response - should have request_id in body
    curl -s http://localhost:8000/graphs/../../etc/passwd | python -m json.tool

    # Test validation error - should have request_id
    curl -s -X POST http://localhost:8000/generate-city -H "Content-Type: application/json" -d '{"n_nodes": 100}' | python -m json.tool
    ```
    - All responses include X-Request-ID header
    - Error responses include request_id in JSON body
    - Request ID is UUID format
  </verify>
  <done>
    - All requests have X-Request-ID response header
    - All error responses include request_id in body
    - Server logs include full context with request_id
    - Client receives only request_id (no internal details)
  </done>
</task>

</tasks>

<verification>
1. Normal request flow:
   ```bash
   curl -v http://localhost:8000/health
   ```
   - Response header: X-Request-ID: <uuid>
   - Response body contains normal health data

2. Custom request ID passthrough:
   ```bash
   curl -v -H "X-Request-ID: my-custom-id-123" http://localhost:8000/health
   ```
   - Response header: X-Request-ID: my-custom-id-123
   - Same ID is used (allows distributed tracing)

3. Error response with request_id:
   ```bash
   curl -s http://localhost:8000/nonexistent | jq .
   ```
   Expected:
   ```json
   {
     "detail": "Not Found",
     "request_id": "<uuid>"
   }
   ```

4. Validation error with request_id:
   ```bash
   curl -s -X POST http://localhost:8000/generate-city \
     -H "Content-Type: application/json" \
     -d '{"n_nodes": 100}' | jq .
   ```
   Expected:
   ```json
   {
     "detail": "Validation error",
     "errors": [...],
     "request_id": "<uuid>"
   }
   ```

5. Server-side logging (check terminal):
   - Error logs include: request_id, method, path, error details
   - No stack traces in client response
</verification>

<success_criteria>
- Every response includes X-Request-ID header
- Error responses include request_id in JSON body
- Server logs full error context (request_id, path, method, error)
- Client responses contain NO internal details (paths, stack traces)
- Incoming X-Request-ID header is respected (distributed tracing support)
- request.state.request_id available in all request handlers
</success_criteria>

<output>
After completion, create `.planning/phases/03-observability/03-03-SUMMARY.md`
</output>
