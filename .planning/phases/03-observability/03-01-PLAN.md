---
phase: 03-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/logging_config.py
  - backend/app/main.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Every request generates a JSON log entry with request ID, timestamp, endpoint, and duration"
    - "Request/response bodies can be logged at DEBUG level without appearing in production INFO logs"
    - "Log entries are structured JSON, not plaintext"
  artifacts:
    - path: "backend/app/logging_config.py"
      provides: "Structlog configuration with JSON formatting"
      exports: ["configure_logging", "get_logger"]
    - path: "backend/app/main.py"
      provides: "Logging middleware integration"
      contains: "LoggingMiddleware"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/logging_config.py"
      via: "import and middleware registration"
      pattern: "from app.logging_config import"
---

<objective>
Set up structured JSON logging with structlog for consistent, machine-parseable log output.

Purpose: Enables operators to search, filter, and analyze logs in production monitoring tools (ELK, Datadog, CloudWatch). JSON logs with consistent fields are essential for observability.

Output: Logging middleware that captures request metadata (ID, endpoint, duration) in JSON format, with configurable log levels for request/response body logging.
</objective>

<execution_context>
@.claude/workflows/execute-plan.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@backend/app/main.py
@backend/src/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create structlog configuration module</name>
  <files>backend/app/logging_config.py, backend/requirements.txt</files>
  <action>
    1. Add `structlog>=24.1.0` to backend/requirements.txt

    2. Create backend/app/logging_config.py with:
       - configure_logging(log_level: str = "INFO") function that:
         - Sets up structlog with JSON renderer for production
         - Configures processors: add_log_level, TimeStamper(fmt="iso"), JSONRenderer
         - Integrates with standard library logging
         - Returns configured logger
       - get_logger(name: str) function that returns a bound logger
       - LOG_LEVEL setting from environment (default INFO)

    3. Key configuration:
       - Use structlog.stdlib.ProcessorFormatter to bridge structlog and stdlib
       - Add timestamper with ISO format
       - Add log level processor
       - Use JSONRenderer for output (not ConsoleRenderer)
       - Configure stdlib logging to use structlog for formatting
  </action>
  <verify>
    - File exists: backend/app/logging_config.py
    - Import succeeds: `python -c "from app.logging_config import configure_logging, get_logger"`
    - structlog in requirements.txt
  </verify>
  <done>Structlog configuration module exists with configure_logging and get_logger functions</done>
</task>

<task type="auto">
  <name>Task 2: Add logging middleware to FastAPI app</name>
  <files>backend/app/main.py</files>
  <action>
    1. Import logging configuration at app startup:
       - from app.logging_config import configure_logging, get_logger
       - Call configure_logging() in lifespan startup

    2. Create LoggingMiddleware class (or use @app.middleware("http")):
       - Generate unique request_id (uuid4) for each request
       - Record start_time at request entry
       - After response, log JSON entry with:
         - request_id
         - timestamp (ISO format)
         - method (GET, POST, etc.)
         - path (endpoint)
         - status_code
         - duration_ms (calculated from start_time)
         - client_ip (from request.client.host)
       - At DEBUG level only: log request body (if POST/PUT) and response body
       - Store request_id in request.state for access in exception handlers

    3. Update global_exception_handler to include request_id in:
       - Server-side log (full context)
       - Client response (just request_id for support reference)

    4. Add LOG_LEVEL to Settings in src/config.py (default: "INFO")
  </action>
  <verify>
    Run backend and make request:
    ```bash
    cd backend && uvicorn app.main:app --reload &
    sleep 2
    curl http://localhost:8000/health
    ```
    - Logs show JSON format with request_id, timestamp, path, duration_ms
    - No request body in INFO logs
    - With LOG_LEVEL=DEBUG, request body appears
  </verify>
  <done>
    - Every request generates JSON log entry with request_id, timestamp, endpoint, duration
    - DEBUG level shows request/response bodies
    - INFO level (production) does not show bodies
  </done>
</task>

</tasks>

<verification>
1. Start backend with default (INFO) log level:
   ```bash
   cd backend && LOG_LEVEL=INFO uvicorn app.main:app --host 0.0.0.0 --port 8000
   ```

2. Make test requests:
   ```bash
   curl http://localhost:8000/health
   curl -X POST http://localhost:8000/generate-city -H "Content-Type: application/json" -d '{"n_nodes": 5}'
   ```

3. Verify log output:
   - Each request produces exactly one JSON log line
   - JSON contains: request_id, timestamp, method, path, status_code, duration_ms
   - No request body visible at INFO level

4. Test DEBUG level:
   ```bash
   LOG_LEVEL=DEBUG uvicorn app.main:app --host 0.0.0.0 --port 8000
   ```
   - Request bodies now visible in logs
</verification>

<success_criteria>
- Every HTTP request generates a structured JSON log entry
- Log entries contain: request_id (UUID), timestamp (ISO), method, path, status_code, duration_ms
- At INFO level: no request/response bodies in logs
- At DEBUG level: request/response bodies included
- Logs are valid JSON (parseable by jq or similar tools)
</success_criteria>

<output>
After completion, create `.planning/phases/03-observability/03-01-SUMMARY.md`
</output>
