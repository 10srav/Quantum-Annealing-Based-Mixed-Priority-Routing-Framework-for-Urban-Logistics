---
phase: 03-observability
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/main.py
  - backend/src/qaoa_solver.py
autonomous: true

must_haves:
  truths:
    - "Health endpoint reports solver availability status"
    - "Health endpoint can detect when Qiskit is unavailable"
    - "Health endpoint returns structured status for each dependency"
  artifacts:
    - path: "backend/app/main.py"
      provides: "Enhanced /health endpoint with dependency checks"
      contains: "dependencies"
    - path: "backend/src/qaoa_solver.py"
      provides: "Solver health check function"
      exports: ["check_solver_health"]
  key_links:
    - from: "backend/app/main.py"
      to: "backend/src/qaoa_solver.py"
      via: "import check_solver_health"
      pattern: "from src.qaoa_solver import.*check_solver_health"
---

<objective>
Enhance the health check endpoint to report dependency status, specifically Qiskit/QAOA solver availability.

Purpose: Operators need to know if the quantum solver is functional before routing traffic. A degraded health status (Qiskit unavailable but greedy solver working) is different from unhealthy (nothing works).

Output: Health endpoint that returns overall status plus per-dependency status, enabling load balancers and monitoring to make informed decisions.
</objective>

<execution_context>
@.claude/workflows/execute-plan.md
@.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-observability/03-01-PLAN.md
@backend/app/main.py
@backend/src/qaoa_solver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add solver health check function</name>
  <files>backend/src/qaoa_solver.py</files>
  <action>
    1. Add check_solver_health() function to qaoa_solver.py:
       ```python
       def check_solver_health() -> dict:
           """Check if QAOA solver is operational."""
           result = {
               "name": "qaoa_solver",
               "status": "healthy",
               "details": {}
           }

           # Check Qiskit availability
           result["details"]["qiskit_available"] = QISKIT_AVAILABLE

           if not QISKIT_AVAILABLE:
               result["status"] = "degraded"
               result["details"]["message"] = "Qiskit not installed, using mock solver"
               return result

           # Try to import critical Qiskit components
           try:
               from qiskit_aer.primitives import Sampler
               from qiskit_algorithms import QAOA
               result["details"]["qiskit_components"] = "ok"
           except ImportError as e:
               result["status"] = "degraded"
               result["details"]["qiskit_components"] = "missing"
               result["details"]["message"] = f"Qiskit component unavailable: {e}"
               return result

           # Optionally: quick smoke test (create sampler instance)
           try:
               _ = Sampler()
               result["details"]["sampler_init"] = "ok"
           except Exception as e:
               result["status"] = "unhealthy"
               result["details"]["sampler_init"] = "failed"
               result["details"]["error"] = str(e)

           return result
       ```

    2. Export check_solver_health in module (add to imports if needed)
  </action>
  <verify>
    ```bash
    cd backend && python -c "from src.qaoa_solver import check_solver_health; print(check_solver_health())"
    ```
    - Returns dict with name, status, details
    - status is "healthy", "degraded", or "unhealthy"
  </verify>
  <done>check_solver_health function exists and returns structured health status</done>
</task>

<task type="auto">
  <name>Task 2: Enhance health endpoint with dependency status</name>
  <files>backend/app/main.py</files>
  <action>
    1. Import check_solver_health:
       ```python
       from src.qaoa_solver import quantum_solve, get_sampler_info, check_solver_health
       ```

    2. Replace existing /health endpoint with enhanced version:
       ```python
       @app.get("/health")
       async def health_check():
           """
           Health check endpoint with dependency status.

           Returns:
               - status: "healthy" | "degraded" | "unhealthy"
               - service: service name
               - timestamp: ISO timestamp
               - dependencies: list of dependency statuses
           """
           from datetime import datetime, timezone

           # Check dependencies
           solver_health = check_solver_health()

           dependencies = [solver_health]

           # Determine overall status (worst of all dependencies)
           statuses = [d["status"] for d in dependencies]
           if "unhealthy" in statuses:
               overall_status = "unhealthy"
           elif "degraded" in statuses:
               overall_status = "degraded"
           else:
               overall_status = "healthy"

           return {
               "status": overall_status,
               "service": "quantum-priority-router",
               "timestamp": datetime.now(timezone.utc).isoformat(),
               "dependencies": dependencies
           }
       ```

    3. Remove the old qaoa_info from health response (now in dependencies)
  </action>
  <verify>
    ```bash
    cd backend && uvicorn app.main:app --reload &
    sleep 2
    curl -s http://localhost:8000/health | python -m json.tool
    ```
    - Response has: status, service, timestamp, dependencies array
    - dependencies[0] has: name, status, details
    - status reflects Qiskit availability (healthy if available, degraded if not)
  </verify>
  <done>
    - Health endpoint returns overall status plus per-dependency status
    - Qiskit availability is reflected in solver dependency status
    - Response is JSON with consistent structure
  </done>
</task>

</tasks>

<verification>
1. Test with Qiskit available:
   ```bash
   curl -s http://localhost:8000/health | jq .
   ```
   Expected:
   ```json
   {
     "status": "healthy",
     "service": "quantum-priority-router",
     "timestamp": "2026-...",
     "dependencies": [
       {
         "name": "qaoa_solver",
         "status": "healthy",
         "details": {
           "qiskit_available": true,
           "qiskit_components": "ok",
           "sampler_init": "ok"
         }
       }
     ]
   }
   ```

2. Test with Qiskit unavailable (if possible, or verify code handles it):
   - Temporarily modify QISKIT_AVAILABLE = False
   - Health should return status: "degraded"

3. Verify response codes:
   - Returns 200 even when degraded (service is running, just limited)
   - Could add 503 for unhealthy if desired (optional)
</verification>

<success_criteria>
- Health endpoint returns JSON with status, service, timestamp, dependencies
- Solver dependency reports: name="qaoa_solver", status, details
- When Qiskit unavailable: status="degraded" with explanatory message
- When Qiskit available and working: status="healthy"
- Response structure is consistent regardless of health state
</success_criteria>

<output>
After completion, create `.planning/phases/03-observability/03-02-SUMMARY.md`
</output>
