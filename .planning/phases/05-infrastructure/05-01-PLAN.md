---
phase: 05-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile
autonomous: true

must_haves:
  truths:
    - "Docker image builds successfully with multi-stage process"
    - "Final image contains only runtime dependencies, not build tools"
    - "Image size is smaller than single-stage equivalent"
  artifacts:
    - path: "backend/Dockerfile"
      provides: "Multi-stage production Dockerfile"
      contains: "FROM python:3.11-slim as builder"
  key_links:
    - from: "backend/Dockerfile"
      to: "requirements.txt"
      via: "COPY and pip install"
      pattern: "COPY requirements.txt"
---

<objective>
Create a production-ready multi-stage Dockerfile for the backend.

Purpose: Reduce image size and attack surface by separating build-time dependencies from runtime.
Output: backend/Dockerfile with builder stage for pip installs and slim runtime stage.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/Dockerfile
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert Dockerfile to multi-stage build</name>
  <files>backend/Dockerfile</files>
  <action>
Replace the existing single-stage Dockerfile with a multi-stage build:

**Stage 1: Builder**
- Base: python:3.11-slim as builder
- Install build dependencies (gcc, etc.) needed for compiling Python packages
- Copy requirements.txt and install dependencies to a virtual environment
- Use: `python -m venv /opt/venv` and install to that venv

**Stage 2: Runtime**
- Base: python:3.11-slim (fresh, no builder cruft)
- Copy only the virtual environment from builder: `COPY --from=builder /opt/venv /opt/venv`
- Set PATH to use venv: `ENV PATH="/opt/venv/bin:$PATH"`
- Copy application source (src/, app/, data/ if exists)
- Create non-root user for security: `RUN useradd -m -u 1000 appuser && chown -R appuser /app`
- Switch to non-root: `USER appuser`
- Expose port 8000
- Use uvicorn with proper settings for production

Key points:
- Do NOT copy requirements.txt to final stage (not needed at runtime)
- Do NOT install curl in final stage unless needed for healthcheck (uvicorn has built-in)
- Final image should have minimal packages
  </action>
  <verify>
Run: `docker build -t quantum-router-backend:test ./backend`
Verify: Build completes without errors
Run: `docker images quantum-router-backend:test --format "{{.Size}}"`
Verify: Image size is smaller than before (aim for under 1.5GB, Qiskit is large)
  </verify>
  <done>
Multi-stage Dockerfile builds successfully, final image contains only runtime dependencies, runs as non-root user.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify image runs correctly</name>
  <files>backend/Dockerfile</files>
  <action>
Test that the built image actually works:

1. Build the image: `docker build -t quantum-router-backend:test ./backend`
2. Run container: `docker run -d -p 8001:8000 --name qr-test quantum-router-backend:test`
3. Wait for startup (2-3 seconds)
4. Test health endpoint: `curl http://localhost:8001/health`
5. Verify response contains "healthy" status
6. Check container logs for any errors: `docker logs qr-test`
7. Clean up: `docker stop qr-test && docker rm qr-test`

If any issues:
- Check that all source files are copied correctly
- Verify PATH includes venv
- Ensure uvicorn can find app.main:app
  </action>
  <verify>
Health endpoint returns 200 with status "healthy"
Container logs show successful startup without errors
  </verify>
  <done>
Production Docker image builds and runs correctly, health check passes.
  </done>
</task>

</tasks>

<verification>
- [ ] `docker build -t quantum-router-backend:test ./backend` succeeds
- [ ] Image has two stages visible in build output
- [ ] Container starts and /health returns 200
- [ ] Image runs as non-root user (check with `docker exec <container> whoami`)
</verification>

<success_criteria>
Docker image builds with multi-stage process (builder stage separate from runtime). Final image is production-ready with non-root user and minimal attack surface.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure/05-01-SUMMARY.md`
</output>
