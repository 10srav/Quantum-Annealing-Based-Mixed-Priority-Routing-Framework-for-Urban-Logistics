---
phase: 05-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/app/main.py
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "In-flight solver requests complete before shutdown on SIGTERM"
    - "Docker Compose production profile sets memory and CPU limits"
    - "Graceful shutdown has configurable timeout"
  artifacts:
    - path: "backend/app/main.py"
      provides: "Graceful shutdown handling in lifespan"
      contains: "shutdown"
    - path: "docker-compose.yml"
      provides: "Production profile with resource limits"
      contains: "deploy"
  key_links:
    - from: "docker-compose.yml"
      to: "backend/Dockerfile"
      via: "build context"
      pattern: "context:.*backend"
---

<objective>
Implement graceful shutdown for the API and add Docker Compose production profile with resource limits.

Purpose: Ensure in-flight requests complete before container stops, and production deployments have proper resource constraints.
Output: Updated main.py with graceful shutdown, docker-compose.yml with production profile.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/app/main.py
@docker-compose.yml
@.planning/phases/05-infrastructure/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement graceful shutdown in FastAPI lifespan</name>
  <files>backend/app/main.py, backend/src/config.py</files>
  <action>
Implement graceful shutdown that allows in-flight requests to complete:

1. Add shutdown timeout to config.py:
```python
shutdown_timeout: int = 30  # seconds to wait for in-flight requests
```

2. Update the lifespan context manager in main.py to track active requests:
```python
import asyncio
from contextlib import asynccontextmanager

# Track active solver requests
active_requests: set[asyncio.Task] = set()
shutdown_event = asyncio.Event()

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan handler with graceful shutdown."""
    # Startup
    logger.info("Quantum Priority Router API starting...")
    yield
    # Shutdown - wait for in-flight requests
    logger.info("Shutdown initiated, waiting for in-flight requests...")
    shutdown_event.set()

    if active_requests:
        logger.info(f"Waiting for {len(active_requests)} active requests to complete...")
        try:
            await asyncio.wait_for(
                asyncio.gather(*active_requests, return_exceptions=True),
                timeout=settings.shutdown_timeout
            )
            logger.info("All requests completed gracefully")
        except asyncio.TimeoutError:
            logger.warning(f"Shutdown timeout ({settings.shutdown_timeout}s) reached, forcing exit")

    logger.info("Shutdown complete")
```

3. Wrap solver endpoints to track active requests:
```python
@app.post("/solve", response_model=SolverResponse)
async def solve_route(request: SolverRequest):
    """Solve routing problem using specified solver."""
    task = asyncio.current_task()
    active_requests.add(task)
    try:
        # existing solver logic
        if request.solver == "quantum":
            result = quantum_solve(...)
        else:
            result = greedy_solve(...)
        return result
    finally:
        active_requests.discard(task)
```

4. Do the same for /compare endpoint.

Alternative simpler approach using middleware:
```python
@app.middleware("http")
async def track_requests(request: Request, call_next):
    task = asyncio.current_task()
    active_requests.add(task)
    try:
        response = await call_next(request)
        return response
    finally:
        active_requests.discard(task)
```

Use the middleware approach - it's cleaner and catches all requests.
  </action>
  <verify>
Test graceful shutdown:
1. Start server
2. Send a long-running solve request (or add artificial delay)
3. Send SIGTERM to process
4. Verify request completes before shutdown
5. Check logs show "waiting for in-flight requests"
  </verify>
  <done>
SIGTERM triggers graceful drain, in-flight requests complete before shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Docker Compose production profile with resource limits</name>
  <files>docker-compose.yml</files>
  <action>
Add a production profile to docker-compose.yml with resource limits:

1. Keep existing development configuration as default
2. Add production profile with deploy section:

```yaml
version: '3.8'

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DWAVE_API_TOKEN=${DWAVE_API_TOKEN}
      - API_HOST=0.0.0.0
      - API_PORT=8000
      - CORS_ORIGINS=${CORS_ORIGINS:-http://localhost:5173,http://localhost:3000}
      - ENVIRONMENT=${ENVIRONMENT:-development}
      - SHUTDOWN_TIMEOUT=${SHUTDOWN_TIMEOUT:-30}
    volumes:
      - ./backend/src:/app/src
      - ./data:/app/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    profiles: ["", "dev"]  # Default profile

  backend-prod:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DWAVE_API_TOKEN=${DWAVE_API_TOKEN}
      - API_HOST=0.0.0.0
      - API_PORT=8000
      - CORS_ORIGINS=${CORS_ORIGINS}
      - ENVIRONMENT=production
      - SHUTDOWN_TIMEOUT=${SHUTDOWN_TIMEOUT:-30}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '0.5'
          memory: 1G
    stop_grace_period: 35s  # Slightly longer than shutdown_timeout
    profiles: ["prod"]

  frontend:
    # ... existing frontend config
    profiles: ["", "dev"]

  frontend-prod:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "80:80"
    environment:
      - VITE_API_URL=${VITE_API_URL:-http://localhost:8000}
    depends_on:
      - backend-prod
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    profiles: ["prod"]
```

Actually, simpler approach - use a single service with conditional deploy:

```yaml
services:
  backend:
    # ... existing config ...
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '0.5'
          memory: 1G
    stop_grace_period: 35s
```

The deploy section is ignored by `docker-compose up` but used by `docker stack deploy` and `docker-compose --compatibility up`.

For clearest separation, use docker-compose.prod.yml override file:
- docker-compose.yml = base config
- docker-compose.prod.yml = production overrides

Create docker-compose.prod.yml with:
```yaml
version: '3.8'

services:
  backend:
    volumes: []  # No source mounts in production
    environment:
      - ENVIRONMENT=production
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '0.5'
          memory: 1G
    stop_grace_period: 35s

  frontend:
    volumes: []
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
```

Usage: `docker-compose -f docker-compose.yml -f docker-compose.prod.yml up`

Implement the override file approach - it's the cleanest.
  </action>
  <verify>
Run: `docker-compose -f docker-compose.yml -f docker-compose.prod.yml config`
Verify: Output shows deploy.resources.limits on services
Verify: stop_grace_period is set
Verify: No volume mounts for source code in production
  </verify>
  <done>
Docker Compose production profile sets memory and CPU limits on containers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify graceful shutdown with Docker</name>
  <files>docker-compose.yml</files>
  <action>
Test that graceful shutdown works in Docker environment:

1. Build and start with production config:
```bash
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build
```

2. Verify container is running:
```bash
docker-compose ps
```

3. Send a request (optional - to have in-flight request):
```bash
curl http://localhost:8000/health
```

4. Stop with SIGTERM:
```bash
docker-compose stop backend
```

5. Check logs for graceful shutdown messages:
```bash
docker-compose logs backend | tail -20
```

Expected log output:
- "Shutdown initiated, waiting for in-flight requests..."
- "Shutdown complete"

6. Verify container exited cleanly (exit code 0):
```bash
docker-compose ps -a
```

7. Clean up:
```bash
docker-compose down
```
  </action>
  <verify>
Container logs show graceful shutdown sequence.
Exit code is 0 (not 137 from SIGKILL).
  </verify>
  <done>
Graceful shutdown works in Docker with SIGTERM triggering clean drain.
  </done>
</task>

</tasks>

<verification>
- [ ] Shutdown timeout is configurable via SHUTDOWN_TIMEOUT env var
- [ ] In-flight requests complete before shutdown (within timeout)
- [ ] `docker-compose -f docker-compose.yml -f docker-compose.prod.yml config` shows resource limits
- [ ] Production config has no source volume mounts
- [ ] stop_grace_period exceeds shutdown_timeout
</verification>

<success_criteria>
In-flight solver requests complete before shutdown (SIGTERM triggers graceful drain). Docker Compose production profile sets memory and CPU limits on containers.
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure/05-03-SUMMARY.md`
</output>
