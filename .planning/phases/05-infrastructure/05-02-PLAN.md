---
phase: 05-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/config.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "CORS origins are configurable via CORS_ORIGINS environment variable"
    - "Requests from unlisted origins are rejected"
    - "Wildcard (*) origin is rejected in production mode"
  artifacts:
    - path: "backend/src/config.py"
      provides: "Environment-based CORS configuration"
      contains: "cors_origins"
    - path: "backend/app/main.py"
      provides: "CORS middleware with configurable origins"
      contains: "CORSMiddleware"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/src/config.py"
      via: "settings.cors_origins"
      pattern: "settings\\.cors_origins"
---

<objective>
Configure CORS to be environment-driven and reject unlisted origins.

Purpose: Allow production deployments to specify allowed frontend domains while blocking unauthorized cross-origin requests.
Output: Updated config.py with CORS_ORIGINS env var parsing, main.py validates and applies origins.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/config.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update config.py for environment-based CORS</name>
  <files>backend/src/config.py</files>
  <action>
Modify the Settings class to properly parse CORS origins from environment:

1. Change `cors_origins` field to parse from comma-separated env var:
```python
cors_origins: list[str] = ["http://localhost:5173", "http://localhost:3000"]
```
Already exists, but needs a validator to parse comma-separated string.

2. Add a field validator or use pydantic's built-in parsing:
```python
from pydantic import field_validator

@field_validator("cors_origins", mode="before")
@classmethod
def parse_cors_origins(cls, v):
    if isinstance(v, str):
        # Parse comma-separated: "http://a.com,http://b.com"
        return [origin.strip() for origin in v.split(",") if origin.strip()]
    return v
```

3. Add environment mode setting:
```python
environment: str = "development"  # development, staging, production
```

4. Add validation that rejects wildcard "*" in production:
```python
@field_validator("cors_origins", mode="after")
@classmethod
def validate_cors_origins(cls, v, info):
    env = info.data.get("environment", "development")
    if env == "production" and "*" in v:
        raise ValueError("Wildcard CORS origin not allowed in production")
    return v
```

Note: Use model_validator if field_validator doesn't have access to other fields.
  </action>
  <verify>
Create test script:
```python
import os
os.environ["CORS_ORIGINS"] = "https://app.example.com,https://admin.example.com"
from src.config import Settings
s = Settings()
assert s.cors_origins == ["https://app.example.com", "https://admin.example.com"]
```
  </verify>
  <done>
CORS origins are parsed from comma-separated CORS_ORIGINS environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Test CORS rejection behavior</name>
  <files>backend/app/main.py</files>
  <action>
Verify that CORS middleware properly rejects unlisted origins:

1. The existing CORSMiddleware setup should already work, but verify it's configured correctly:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,  # List of allowed origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

2. Write a test to verify rejection:
- Start server with CORS_ORIGINS="http://allowed.com"
- Send request with Origin: http://notallowed.com
- Verify Access-Control-Allow-Origin header is NOT present in response

3. Test in backend/tests/test_api.py or a standalone script:
```python
import httpx

# Test with disallowed origin
response = httpx.get(
    "http://localhost:8000/health",
    headers={"Origin": "http://evil.com"}
)
# CORS headers should be absent for disallowed origins
assert "access-control-allow-origin" not in response.headers
```

Note: FastAPI's CORS middleware doesn't return 403 for bad origins - it just omits the CORS headers, which causes browser to block the response. This is standard CORS behavior.
  </action>
  <verify>
Run: `pytest backend/tests/test_api.py -v -k cors` (if test exists)
Or manual test:
1. Set CORS_ORIGINS=http://allowed.com
2. Run server
3. curl -H "Origin: http://evil.com" http://localhost:8000/health -v
4. Verify no Access-Control-Allow-Origin header in response
  </verify>
  <done>
Requests from unlisted origins do not receive CORS headers (browser will block).
  </done>
</task>

</tasks>

<verification>
- [ ] CORS_ORIGINS env var is parsed as comma-separated list
- [ ] Default origins still work for development
- [ ] Requests with unlisted Origin header don't get CORS headers
- [ ] Wildcard "*" is rejected when ENVIRONMENT=production
</verification>

<success_criteria>
CORS origins are configurable via environment variable and reject requests from unlisted origins (by omitting CORS headers, causing browser rejection).
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure/05-02-SUMMARY.md`
</output>
