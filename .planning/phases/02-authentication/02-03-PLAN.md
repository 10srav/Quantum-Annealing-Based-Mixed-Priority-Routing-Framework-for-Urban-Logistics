---
phase: 02-authentication
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/config.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Solver requests exceeding timeout return 504 Gateway Timeout"
    - "504 response includes clear error message"
    - "Timeout is configurable via environment variable"
    - "Non-solver endpoints are not affected by solver timeout"
  artifacts:
    - path: "backend/src/config.py"
      provides: "Timeout configuration"
      contains: "solver_timeout_seconds"
    - path: "backend/app/main.py"
      provides: "Timeout handling for solver endpoints"
      contains: "asyncio.wait_for"
  key_links:
    - from: "backend/app/main.py"
      to: "asyncio"
      via: "wait_for timeout wrapper"
      pattern: "asyncio.wait_for.*timeout"
---

<objective>
Implement request timeout handling for solver endpoints to prevent hanging requests.

Purpose: Ensure solver requests that exceed a configurable timeout return 504 Gateway Timeout instead of hanging indefinitely.

Output: Solver endpoints (/solve, /compare) timeout after configurable duration with proper 504 response.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication/02-01-PLAN.md
@backend/app/main.py
@backend/src/config.py
@backend/src/qaoa_solver.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timeout configuration</name>
  <files>backend/src/config.py, backend/.env.example</files>
  <action>
1. Update `backend/src/config.py` Settings class:
   ```python
   # Timeout Settings
   solver_timeout_seconds: int = 30  # Max time for solver endpoints
   ```

2. Update `backend/.env.example`:
   ```
   # Timeout Configuration
   SOLVER_TIMEOUT_SECONDS=30
   ```

The default of 30 seconds is reasonable for QAOA solver on small graphs.
For larger graphs or production, this can be increased via environment variable.
  </action>
  <verify>
- `solver_timeout_seconds` field exists in Settings class
- `.env.example` documents the timeout setting
  </verify>
  <done>
Timeout configuration added with 30-second default.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement timeout wrapper for solver endpoints</name>
  <files>backend/app/main.py</files>
  <action>
Modify `backend/app/main.py`:

1. Add imports:
   ```python
   import asyncio
   from functools import partial
   ```

2. Create async wrapper for sync solver functions:
   ```python
   async def run_solver_with_timeout(solver_func, *args, **kwargs):
       """
       Run a synchronous solver function with timeout.
       Wraps sync function in executor and applies timeout.
       """
       loop = asyncio.get_event_loop()
       func = partial(solver_func, *args, **kwargs)
       try:
           result = await asyncio.wait_for(
               loop.run_in_executor(None, func),
               timeout=settings.solver_timeout_seconds
           )
           return result
       except asyncio.TimeoutError:
           raise HTTPException(
               status_code=504,
               detail=f"Solver request timed out after {settings.solver_timeout_seconds} seconds"
           )
   ```

3. Update `/solve` endpoint:
   ```python
   @app.post("/solve", response_model=SolverResponse)
   @limiter.limit(f"{settings.rate_limit_solver_per_minute}/minute")
   async def solve_route(request: Request, solver_request: SolverRequest, _: bool = Depends(verify_api_key)):
       """Solve routing problem using specified solver."""
       if solver_request.solver == "quantum":
           result = await run_solver_with_timeout(
               quantum_solve,
               solver_request.graph,
               solver_request.params,
               use_mock=settings.qaoa_use_mock
           )
       else:
           result = await run_solver_with_timeout(
               greedy_solve,
               solver_request.graph
           )
       return result
   ```

4. Update `/compare` endpoint similarly:
   ```python
   @app.post("/compare", response_model=ComparisonResponse)
   @limiter.limit(f"{settings.rate_limit_solver_per_minute}/minute")
   async def compare_solvers(request: Request, graph: CityGraph, _: bool = Depends(verify_api_key)):
       """Run both solvers and compare results."""
       quantum_result = await run_solver_with_timeout(
           quantum_solve,
           graph,
           use_mock=settings.qaoa_use_mock
       )
       greedy_result = await run_solver_with_timeout(
           greedy_solve,
           graph
       )
       return compare_solutions(greedy_result, quantum_result)
   ```

Note: Both solver calls in /compare use the same timeout individually.
If both need to complete, worst case is 2x timeout (60s with default 30s each).
  </action>
  <verify>
Check implementation:
```bash
grep -n "asyncio.wait_for" backend/app/main.py
grep -n "504" backend/app/main.py
```
Should show timeout wrapper with 504 error handling.
  </verify>
  <done>
Solver endpoints wrapped with configurable timeout, returning 504 on timeout.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test timeout behavior</name>
  <files>None (testing only)</files>
  <action>
Testing timeout is challenging without a slow solver. Options:

1. **Unit test approach** (recommended for CI):
   Create a test that mocks the solver to sleep longer than timeout:
   ```python
   # In tests/test_api.py
   import pytest
   from unittest.mock import patch
   import time

   def slow_solver(*args, **kwargs):
       time.sleep(5)  # Longer than test timeout
       return {"route": [], "metrics": {}}

   @pytest.mark.asyncio
   async def test_solver_timeout():
       # Set very short timeout for testing
       with patch('src.config.Settings.solver_timeout_seconds', 1):
           # ... test that 504 is returned
   ```

2. **Manual verification** (for development):
   - Temporarily set `SOLVER_TIMEOUT_SECONDS=1` in .env
   - Send a request to /solve with a larger graph (15+ nodes)
   - Verify 504 response if it doesn't complete in 1 second
   - Reset timeout to normal value

3. **Verify error message format**:
   When 504 occurs, response should be:
   ```json
   {"detail": "Solver request timed out after 30 seconds"}
   ```

4. **Verify non-solver endpoints unaffected**:
   - /generate-city should not have solver timeout (it's fast)
   - /graphs endpoints should not have solver timeout
  </action>
  <verify>
- Solver endpoint returns 504 when timeout exceeded
- Error message includes timeout duration
- Non-solver endpoints work without timeout wrapper
  </verify>
  <done>
Timeout handling verified. AUTH-04 satisfied: Solver requests exceeding timeout return 504.
  </done>
</task>

</tasks>

<verification>
1. POST /solve with slow operation returns 504 after timeout
2. POST /compare returns 504 if either solver times out
3. 504 response body contains clear timeout message with duration
4. Timeout is configurable via SOLVER_TIMEOUT_SECONDS environment variable
5. Non-solver endpoints (/graphs, /generate-city) are not affected
</verification>

<success_criteria>
- AUTH-04 satisfied: Solver requests exceeding timeout return 504 Gateway Timeout
- Timeout value configurable via environment
- Clear error message in 504 response
- Only solver endpoints affected (targeted timeout, not global)
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-03-SUMMARY.md`
</output>
