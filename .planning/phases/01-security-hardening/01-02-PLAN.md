---
phase: 01-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/exceptions.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Unhandled exceptions return generic 500 message without stack traces"
    - "HTTP exceptions return their defined status codes and safe messages"
    - "Full error details are logged server-side with exc_info"
    - "Validation errors return 400 with field-specific messages"
  artifacts:
    - path: "backend/app/exceptions.py"
      provides: "Custom exception classes for domain errors"
      exports: ["GraphNotFoundError", "InvalidGraphNameError", "NodeLimitExceededError"]
    - path: "backend/app/main.py"
      provides: "Global exception handlers for error sanitization"
      contains: ["@app.exception_handler(Exception)", "@app.exception_handler(RequestValidationError)"]
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/exceptions.py"
      via: "import custom exceptions"
      pattern: "from app.exceptions import"
---

<objective>
Implement error sanitization by adding global exception handlers that log full details server-side and return generic messages to clients.

Purpose: Prevent information disclosure through error messages (stack traces, file paths, library versions) that could aid attackers.
Output: New `exceptions.py` with custom exception classes, and exception handlers in `main.py`.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

Key references:
@backend/app/main.py (current exception handling - bare `except Exception` with str(e))
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create exceptions.py with custom exception classes</name>
  <files>backend/app/exceptions.py</files>
  <action>
Create new file `backend/app/exceptions.py` with:

1. Import `from fastapi import HTTPException`
2. Define custom exceptions inheriting from HTTPException:

```python
class GraphNotFoundError(HTTPException):
    """Raised when requested graph file doesn't exist."""
    def __init__(self, graph_name: str):
        super().__init__(
            status_code=404,
            detail=f"Graph '{graph_name}' not found"
        )

class InvalidGraphNameError(HTTPException):
    """Raised when graph name fails validation."""
    def __init__(self):
        super().__init__(
            status_code=400,
            detail="Invalid graph name: use only letters, numbers, hyphens, and underscores"
        )

class NodeLimitExceededError(HTTPException):
    """Raised when node count exceeds maximum."""
    def __init__(self, max_nodes: int):
        super().__init__(
            status_code=400,
            detail=f"Node count exceeds maximum allowed ({max_nodes})"
        )
```

Include docstrings for each exception class.
  </action>
  <verify>
Run: `python -c "from backend.app.exceptions import GraphNotFoundError, InvalidGraphNameError, NodeLimitExceededError; print('Import OK')"`
  </verify>
  <done>exceptions.py exists with GraphNotFoundError, InvalidGraphNameError, and NodeLimitExceededError classes</done>
</task>

<task type="auto">
  <name>Task 2: Add global exception handlers to main.py</name>
  <files>backend/app/main.py</files>
  <action>
Modify `backend/app/main.py`:

1. Add imports at top:
   ```python
   import logging
   from fastapi import Request
   from fastapi.responses import JSONResponse
   from fastapi.exceptions import RequestValidationError
   from starlette.exceptions import HTTPException as StarletteHTTPException
   ```

2. Add logger after imports: `logger = logging.getLogger(__name__)`

3. Add three exception handlers AFTER app creation but BEFORE route definitions:

   a. RequestValidationError handler (for Pydantic validation errors):
   ```python
   @app.exception_handler(RequestValidationError)
   async def validation_exception_handler(request: Request, exc: RequestValidationError):
       """Handle Pydantic validation errors with field-specific messages."""
       errors = []
       for error in exc.errors():
           field = ".".join(str(loc) for loc in error["loc"])
           errors.append({"field": field, "message": error["msg"]})
       return JSONResponse(
           status_code=400,
           content={"detail": "Validation error", "errors": errors}
       )
   ```

   b. StarletteHTTPException handler (for HTTP exceptions):
   ```python
   @app.exception_handler(StarletteHTTPException)
   async def http_exception_handler(request: Request, exc: StarletteHTTPException):
       """Handle HTTP exceptions with consistent format."""
       return JSONResponse(
           status_code=exc.status_code,
           content={"detail": exc.detail}
       )
   ```

   c. Global Exception handler (catch-all for unexpected errors):
   ```python
   @app.exception_handler(Exception)
   async def global_exception_handler(request: Request, exc: Exception):
       """Catch-all for unexpected errors. Logs full details, returns safe message."""
       logger.error(
           f"Unhandled exception on {request.method} {request.url.path}",
           exc_info=True
       )
       return JSONResponse(
           status_code=500,
           content={"detail": "An internal error occurred. Please try again later."}
       )
   ```

4. Update existing endpoints to remove bare `except Exception as e: raise HTTPException(500, str(e))` patterns:
   - In `/solve` endpoint: Remove try/except, let errors bubble to global handler
   - In `/compare` endpoint: Remove try/except, let errors bubble to global handler
   - In `/generate-city` endpoint: Remove try/except, let errors bubble to global handler

   These endpoints should just call their respective functions directly without try/except wrappers.
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
from app.main import app
handlers = [str(h) for h in app.exception_handlers.keys()]
print('Exception handlers registered:', handlers)
assert Exception in app.exception_handlers, 'Global handler missing'
print('Global exception handler: OK')
"
```
  </verify>
  <done>Exception handlers registered and bare except blocks removed from endpoints</done>
</task>

</tasks>

<verification>
Manual verification:
1. Start the API: `cd backend && uvicorn app.main:app --reload`
2. Test intentional error: Send malformed JSON to `/solve` endpoint
   ```bash
   curl -X POST http://localhost:8000/solve -H "Content-Type: application/json" -d '{"invalid": json}'
   ```
   Should return 400 with validation error, no stack trace
3. Check server logs for full error details with stack trace
4. Test that 404/400/500 responses all have consistent `{"detail": "..."}` format
</verification>

<success_criteria>
- Unhandled exceptions return `{"detail": "An internal error occurred. Please try again later."}` with 500 status
- HTTP exceptions return their specific status codes and messages
- Validation errors return 400 with field-specific error messages
- Server logs contain full stack traces with `exc_info=True`
- No stack traces, file paths, or library names visible in API responses
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-02-SUMMARY.md`
</output>
