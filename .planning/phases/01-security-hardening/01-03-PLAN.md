---
phase: 01-security-hardening
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - backend/src/data_models.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "Node count requests above 25 are rejected with clear validation error"
    - "Node count below 2 is rejected with validation error"
    - "priority_ratio outside 0.0-1.0 is rejected"
    - "traffic_profile accepts only valid enum values"
    - "Validation errors include field name and constraint violated"
  artifacts:
    - path: "backend/src/data_models.py"
      provides: "GenerateCityRequest model with validated bounds"
      exports: ["GenerateCityRequest"]
      contains: "Field(ge=2, le="
    - path: "backend/app/main.py"
      provides: "generate-city endpoint using GenerateCityRequest model"
      contains: "GenerateCityRequest"
  key_links:
    - from: "backend/app/main.py"
      to: "backend/src/data_models.py"
      via: "import GenerateCityRequest"
      pattern: "from src.data_models import.*GenerateCityRequest"
---

<objective>
Add Pydantic input validation to the `/generate-city` endpoint with proper bounds checking on node count and all parameters.

Purpose: Prevent DoS attacks via excessive node counts and ensure all inputs are validated before processing.
Output: New `GenerateCityRequest` model with Field constraints, and updated endpoint using the model.
</objective>

<execution_context>
@C:\Users\polli\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\polli\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-security-hardening/01-RESEARCH.md
@.planning/phases/01-security-hardening/01-02-SUMMARY.md

Key references:
@backend/src/data_models.py (existing models to extend)
@backend/src/config.py (max_nodes setting to reference)
@backend/app/main.py (generate-city endpoint to update)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GenerateCityRequest model with validated bounds</name>
  <files>backend/src/data_models.py</files>
  <action>
Add to `backend/src/data_models.py`:

1. Import at top (if not already present): `from typing import Literal`

2. Add new request model after existing models (before SolverRequest):

```python
class GenerateCityRequest(BaseModel):
    """Validated request for city generation with bounds checking."""
    n_nodes: int = Field(
        default=10,
        ge=2,
        le=25,
        description="Number of nodes to generate (2-25)"
    )
    priority_ratio: float = Field(
        default=0.3,
        ge=0.0,
        le=1.0,
        description="Ratio of priority nodes (0.0-1.0)"
    )
    traffic_profile: Literal["low", "medium", "high", "mixed"] = Field(
        default="mixed",
        description="Traffic intensity profile"
    )
    seed: int | None = Field(
        default=None,
        description="Random seed for reproducibility"
    )
```

Note: Using hardcoded `le=25` here is acceptable - the `max_nodes` config value is 25 and this is a fundamental constraint of the QAOA solver. The research notes this as a pitfall but in this case the value is stable and documented in PROJECT.md.
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
from src.data_models import GenerateCityRequest
from pydantic import ValidationError

# Test valid request
req = GenerateCityRequest(n_nodes=10)
print(f'Valid request: {req.n_nodes} nodes')

# Test node limit exceeded
try:
    GenerateCityRequest(n_nodes=30)
    print('FAIL: should have rejected n_nodes=30')
except ValidationError as e:
    print(f'Node limit enforced: {e.errors()[0][\"msg\"]}')

# Test minimum nodes
try:
    GenerateCityRequest(n_nodes=1)
    print('FAIL: should have rejected n_nodes=1')
except ValidationError as e:
    print(f'Minimum enforced: {e.errors()[0][\"msg\"]}')
"
```
  </verify>
  <done>GenerateCityRequest model validates n_nodes between 2-25, priority_ratio between 0-1</done>
</task>

<task type="auto">
  <name>Task 2: Update generate-city endpoint to use request model</name>
  <files>backend/app/main.py</files>
  <action>
Modify `backend/app/main.py`:

1. Update import from data_models to include GenerateCityRequest:
   ```python
   from src.data_models import (
       CityGraph,
       SolverRequest,
       SolverResponse,
       ComparisonResponse,
       QUBOParams,
       GenerateCityRequest,  # Add this
   )
   ```

2. Replace the `/generate-city` endpoint:

   FROM (individual query parameters):
   ```python
   @app.post("/generate-city", response_model=CityGraph)
   async def generate_city(
       n_nodes: int = 10,
       priority_ratio: float = 0.3,
       traffic_profile: str = "mixed",
       seed: int | None = None
   ):
   ```

   TO (request body model):
   ```python
   @app.post("/generate-city", response_model=CityGraph)
   async def generate_city(request: GenerateCityRequest):
       """
       Generate a random city graph for testing.

       Parameters are validated:
       - n_nodes: 2-25 (QAOA solver limit)
       - priority_ratio: 0.0-1.0
       - traffic_profile: low, medium, high, or mixed
       """
       return generate_random_city(
           n_nodes=request.n_nodes,
           priority_ratio=request.priority_ratio,
           traffic_profile=request.traffic_profile,
           seed=request.seed
       )
   ```

   Note: This changes the API from query parameters to JSON body. The existing docstring mentions "for testing" so this is acceptable as a breaking change for security.
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
import asyncio
from app.main import generate_city
from src.data_models import GenerateCityRequest

# Test with valid request
req = GenerateCityRequest(n_nodes=5, priority_ratio=0.2)
result = asyncio.run(generate_city(req))
print(f'Generated city with {len(result.nodes)} nodes')
assert len(result.nodes) == 5, 'Node count mismatch'
print('Endpoint works with request model')
"
```
  </verify>
  <done>generate-city endpoint uses GenerateCityRequest model and validates all inputs</done>
</task>

</tasks>

<verification>
Manual verification:
1. Start the API: `cd backend && uvicorn app.main:app --reload`
2. Test valid request:
   ```bash
   curl -X POST http://localhost:8000/generate-city \
     -H "Content-Type: application/json" \
     -d '{"n_nodes": 10, "priority_ratio": 0.3}'
   ```
   Should return city graph with 10 nodes
3. Test node limit exceeded:
   ```bash
   curl -X POST http://localhost:8000/generate-city \
     -H "Content-Type: application/json" \
     -d '{"n_nodes": 50}'
   ```
   Should return 400 with validation error mentioning "less than or equal to 25"
4. Test invalid priority ratio:
   ```bash
   curl -X POST http://localhost:8000/generate-city \
     -H "Content-Type: application/json" \
     -d '{"n_nodes": 10, "priority_ratio": 1.5}'
   ```
   Should return 400 with validation error
5. Test invalid traffic profile:
   ```bash
   curl -X POST http://localhost:8000/generate-city \
     -H "Content-Type: application/json" \
     -d '{"n_nodes": 10, "traffic_profile": "extreme"}'
   ```
   Should return 400 with validation error
</verification>

<success_criteria>
- n_nodes > 25 returns 400 with field-specific validation error
- n_nodes < 2 returns 400 with validation error
- priority_ratio outside 0.0-1.0 returns 400
- traffic_profile must be "low", "medium", "high", or "mixed"
- Valid requests work and return city graph
- Validation errors include the field name that failed
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-03-SUMMARY.md`
</output>
